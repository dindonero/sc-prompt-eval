{
  "findings": [
    {
      "title": "Incorrect exponent operator use causes overflow in setSupply",
      "category": "arithmetic",
      "severity": "high",
      "confidence": 0.9,
      "evidence": {
        "file": "daoPOLSKAtokens.sol",
        "lines": [
          106,
          107
        ],
        "function": "setSupply"
      },
      "explanation": "The contract uses the exponent operator (`**`) to compute `supplylimit = supplyLOCKER ** uint256(decimals)`. This is not equivalent to multiplying by 10^decimals and can overflow unexpectedly.",
      "fix_suggestion": "Use SafeMath and compute `supplylimit = safeMul(supplyLOCKER, 10 ** uint256(decimals))` instead of using the exponent operator.",
      "key_variables": [],
      "key_statements": [],
      "scenario_matched": "",
      "property_verified": "",
      "static_check_type": "",
      "source": "",
      "static_confirmed": null,
      "static_check_reason": ""
    },
    {
      "title": "Incorrect exponent operator use causes overflow in setotherchainstotalsupply",
      "category": "arithmetic",
      "severity": "high",
      "confidence": 0.9,
      "evidence": {
        "file": "daoPOLSKAtokens.sol",
        "lines": [
          115,
          116
        ],
        "function": "setotherchainstotalsupply"
      },
      "explanation": "The contract uses the exponent operator (`**`) to compute `otherchainstotalsupply = supplyLOCKER ** uint256(decimals)`. This can overflow and does not correctly represent scaling by 10^decimals.",
      "fix_suggestion": "Use SafeMath and compute `otherchainstotalsupply = safeMul(supplyLOCKER, 10 ** uint256(decimals))` instead of using the exponent operator.",
      "key_variables": [],
      "key_statements": [],
      "scenario_matched": "",
      "property_verified": "",
      "static_check_type": "",
      "source": "",
      "static_confirmed": null,
      "static_check_reason": ""
    },
    {
      "title": "Unchecked multiplication overflow in token creation",
      "category": "arithmetic",
      "severity": "medium",
      "confidence": 0.9,
      "evidence": {
        "file": "daoPOLSKAtokens.sol",
        "lines": [
          208,
          209
        ],
        "function": "createDaoPOLSKAtokens"
      },
      "explanation": "The code calculates `numTokens = msg.value * CreationRate` without using SafeMath. A sufficiently large `msg.value` can cause an integer overflow.",
      "fix_suggestion": "Use SafeMath to perform multiplication: `numTokens = safeMul(msg.value, CreationRate)`.",
      "key_variables": [],
      "key_statements": [],
      "scenario_matched": "",
      "property_verified": "",
      "static_check_type": "",
      "source": "",
      "static_confirmed": null,
      "static_check_reason": ""
    },
    {
      "title": "Token creation not restricted by funding period",
      "category": "logic",
      "severity": "medium",
      "confidence": 0.9,
      "evidence": {
        "file": "daoPOLSKAtokens.sol",
        "lines": [
          200,
          219
        ],
        "function": "createDaoPOLSKAtokens"
      },
      "explanation": "The `createDaoPOLSKAtokens` function allows token minting as long as `funding` is true, but there is no check against `fundingEndBlock`. After the intended ICO period, tokens can still be created.",
      "fix_suggestion": "Add a check `require(block.number <= fundingEndBlock);` (or similar) to enforce the ICO time window.",
      "key_variables": [],
      "key_statements": [],
      "scenario_matched": "",
      "property_verified": "",
      "static_check_type": "",
      "source": "",
      "static_confirmed": null,
      "static_check_reason": ""
    },
    {
      "title": "Anyone can call finalize and flip funding/refund state",
      "category": "access_control",
      "severity": "medium",
      "confidence": 0.9,
      "evidence": {
        "file": "daoPOLSKAtokens.sol",
        "lines": [
          257,
          261
        ],
        "function": "finalize"
      },
      "explanation": "The `finalize` function lacks an `onlyOwner` guard, so any address can call it after the block threshold and toggle `funding` and `refundstate`.",
      "fix_suggestion": "Restrict `finalize` to the owner or migrationMaster by adding `require(msg.sender == owner);` at the start.",
      "key_variables": [],
      "key_statements": [],
      "scenario_matched": "",
      "property_verified": "",
      "static_check_type": "",
      "source": "",
      "static_confirmed": null,
      "static_check_reason": ""
    },
    {
      "title": "approveAndCall makes external call without reentrancy guard",
      "category": "reentrancy",
      "severity": "medium",
      "confidence": 0.6,
      "evidence": {
        "file": "daoPOLSKAtokens.sol",
        "lines": [
          133,
          138
        ],
        "function": "approveAndCall"
      },
      "explanation": "`approveAndCall` first calls `approve` then performs an external call to the `_spender` contract (`receiveApproval`). A malicious `_spender` could re-enter.",
      "fix_suggestion": "Use the checks-effects-interactions pattern: perform state changes before the external call and/or add a reentrancy guard.",
      "key_variables": [],
      "key_statements": [],
      "scenario_matched": "",
      "property_verified": "",
      "static_check_type": "",
      "source": "",
      "static_confirmed": null,
      "static_check_reason": ""
    },
    {
      "title": "Unchecked return value from owner.send in PartialFundsTransfer",
      "category": "denial_of_service",
      "severity": "medium",
      "confidence": 0.9,
      "evidence": {
        "file": "daoPOLSKAtokens.sol",
        "lines": [
          243,
          246
        ],
        "function": "PartialFundsTransfer"
      },
      "explanation": "The contract calls `owner.send` without checking the return value. If the send fails, funds will remain locked in the contract.",
      "fix_suggestion": "Check the return value of `send` and revert on failure, or use `transfer` which throws on failure.",
      "key_variables": [],
      "key_statements": [],
      "scenario_matched": "",
      "property_verified": "",
      "static_check_type": "",
      "source": "",
      "static_confirmed": null,
      "static_check_reason": ""
    }
  ],
  "parse_errors": [],
  "finding_count": 7,
  "ground_truth": [
    {
      "category": "unchecked_low_level_calls",
      "lines": [
        439
      ],
      "title": "Unchecked Return Values"
    },
    {
      "category": "unchecked_low_level_calls",
      "lines": [
        465
      ],
      "title": "Unchecked Return Values"
    }
  ],
  "metrics": {
    "category_metrics": {
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "tp": 0,
      "fp": 5,
      "fn": 1,
      "pred_categories": [
        "reentrancy",
        "access_control",
        "arithmetic",
        "denial_of_service"
      ],
      "gt_categories": [
        "unchecked_low_level_calls"
      ],
      "matched_categories": [],
      "missed_categories": [
        "unchecked_low_level_calls"
      ],
      "spurious_categories": [
        "reentrancy",
        "access_control",
        "arithmetic",
        "denial_of_service"
      ],
      "unknown_predictions": 1
    },
    "instance_metrics": {
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "tp": 0,
      "fp": 7,
      "fn": 2,
      "matched_instances": [],
      "unmatched_predictions": [
        {
          "category": "arithmetic",
          "lines": [
            106,
            107
          ],
          "title": "Incorrect exponent operator use causes overflow in setSupply"
        },
        {
          "category": "arithmetic",
          "lines": [
            115,
            116
          ],
          "title": "Incorrect exponent operator use causes overflow in setotherchainstotalsupply"
        },
        {
          "category": "arithmetic",
          "lines": [
            208,
            209
          ],
          "title": "Unchecked multiplication overflow in token creation"
        },
        {
          "category": "unknown",
          "lines": [
            200,
            219
          ],
          "title": "Token creation not restricted by funding period"
        },
        {
          "category": "access_control",
          "lines": [
            257,
            261
          ],
          "title": "Anyone can call finalize and flip funding/refund state"
        },
        {
          "category": "reentrancy",
          "lines": [
            138,
            133
          ],
          "title": "approveAndCall makes external call without reentrancy guard"
        },
        {
          "category": "denial_of_service",
          "lines": [
            243,
            246
          ],
          "title": "Unchecked return value from owner.send in PartialFundsTransfer"
        }
      ],
      "unmatched_ground_truth": [
        {
          "category": "unchecked_low_level_calls",
          "lines": [
            439
          ]
        },
        {
          "category": "unchecked_low_level_calls",
          "lines": [
            465
          ]
        }
      ],
      "has_line_annotations": true
    },
    "precision": 0.0,
    "recall": 0.0,
    "f1": 0.0,
    "tp": 0,
    "fp": 5,
    "fn": 1,
    "pred_categories": [
      "reentrancy",
      "access_control",
      "arithmetic",
      "denial_of_service"
    ],
    "gt_categories": [
      "unchecked_low_level_calls"
    ],
    "matched_categories": [],
    "missed_categories": [
      "unchecked_low_level_calls"
    ],
    "spurious_categories": [
      "reentrancy",
      "access_control",
      "arithmetic",
      "denial_of_service"
    ],
    "unknown_predictions": 1
  },
  "loc": {
    "loc_total": 484,
    "loc_code": 320,
    "loc_comments": 79,
    "loc_blank": 85
  },
  "runner_metadata": {
    "parse_errors": [],
    "raw_output": "[\n  {\n    \"category\": \"arithmetic\",\n    \"title\": \"Incorrect exponent operator use causes overflow in setSupply\",\n    \"severity\": \"high\",\n    \"confidence\": \"high\",\n    \"evidence\": {\n      \"file\": \"daoPOLSKAtokens.sol\",\n      \"lines\": [106, 107],\n      \"function\": \"setSupply\"\n    },\n    \"explanation\": \"The contract uses the exponent operator (`**`) to compute `supplylimit = supplyLOCKER ** uint256(decimals)`. This is not equivalent to multiplying by 10^decimals and can overflow unexpectedly.\",\n    \"fix_suggestion\": \"Use SafeMath and compute `supplylimit = safeMul(supplyLOCKER, 10 ** uint256(decimals))` instead of using the exponent operator.\"\n  },\n  {\n    \"category\": \"arithmetic\",\n    \"title\": \"Incorrect exponent operator use causes overflow in setotherchainstotalsupply\",\n    \"severity\": \"high\",\n    \"confidence\": \"high\",\n    \"evidence\": {\n      \"file\": \"daoPOLSKAtokens.sol\",\n      \"lines\": [115, 116],\n      \"function\": \"setotherchainstotalsupply\"\n    },\n    \"explanation\": \"The contract uses the exponent operator (`**`) to compute `otherchainstotalsupply = supplyLOCKER ** uint256(decimals)`. This can overflow and does not correctly represent scaling by 10^decimals.\",\n    \"fix_suggestion\": \"Use SafeMath and compute `otherchainstotalsupply = safeMul(supplyLOCKER, 10 ** uint256(decimals))` instead of using the exponent operator.\"\n  },\n  {\n    \"category\": \"arithmetic\",\n    \"title\": \"Unchecked multiplication overflow in token creation\",\n    \"severity\": \"medium\",\n    \"confidence\": \"high\",\n    \"evidence\": {\n      \"file\": \"daoPOLSKAtokens.sol\",\n      \"lines\": [208, 209],\n      \"function\": \"createDaoPOLSKAtokens\"\n    },\n    \"explanation\": \"The code calculates `numTokens = msg.value * CreationRate` without using SafeMath. A sufficiently large `msg.value` can cause an integer overflow.\",\n    \"fix_suggestion\": \"Use SafeMath to perform multiplication: `numTokens = safeMul(msg.value, CreationRate)`.\"\n  },\n  {\n    \"category\": \"logic\",\n    \"title\": \"Token creation not restricted by funding period\",\n    \"severity\": \"medium\",\n    \"confidence\": \"high\",\n    \"evidence\": {\n      \"file\": \"daoPOLSKAtokens.sol\",\n      \"lines\": [200, 219],\n      \"function\": \"createDaoPOLSKAtokens\"\n    },\n    \"explanation\": \"The `createDaoPOLSKAtokens` function allows token minting as long as `funding` is true, but there is no check against `fundingEndBlock`. After the intended ICO period, tokens can still be created.\",\n    \"fix_suggestion\": \"Add a check `require(block.number <= fundingEndBlock);` (or similar) to enforce the ICO time window.\"\n  },\n  {\n    \"category\": \"access_control\",\n    \"title\": \"Anyone can call finalize and flip funding/refund state\",\n    \"severity\": \"medium\",\n    \"confidence\": \"high\",\n    \"evidence\": {\n      \"file\": \"daoPOLSKAtokens.sol\",\n      \"lines\": [257, 261],\n      \"function\": \"finalize\"\n    },\n    \"explanation\": \"The `finalize` function lacks an `onlyOwner` guard, so any address can call it after the block threshold and toggle `funding` and `refundstate`.\",\n    \"fix_suggestion\": \"Restrict `finalize` to the owner or migrationMaster by adding `require(msg.sender == owner);` at the start.\"\n  },\n  {\n    \"category\": \"reentrancy\",\n    \"title\": \"approveAndCall makes external call without reentrancy guard\",\n    \"severity\": \"medium\",\n    \"confidence\": \"medium\",\n    \"evidence\": {\n      \"file\": \"daoPOLSKAtokens.sol\",\n      \"lines\": [133, 138],\n      \"function\": \"approveAndCall\"\n    },\n    \"explanation\": \"`approveAndCall` first calls `approve` then performs an external call to the `_spender` contract (`receiveApproval`). A malicious `_spender` could re-enter.\",\n    \"fix_suggestion\": \"Use the checks-effects-interactions pattern: perform state changes before the external call and/or add a reentrancy guard.\"\n  },\n  {\n    \"category\": \"denial_of_service\",\n    \"title\": \"Unchecked return value from owner.send in PartialFundsTransfer\",\n    \"severity\": \"medium\",\n    \"confidence\": \"high\",\n    \"evidence\": {\n      \"file\": \"daoPOLSKAtokens.sol\",\n      \"lines\": [243, 246],\n      \"function\": \"PartialFundsTransfer\"\n    },\n    \"explanation\": \"The contract calls `owner.send` without checking the return value. If the send fails, funds will remain locked in the contract.\",\n    \"fix_suggestion\": \"Check the return value of `send` and revert on failure, or use `transfer` which throws on failure.\"\n  }\n]",
    "rendered_prompt": "You are a security auditor specializing in Solidity.\n\nTask:\n1) Audit the following Solidity contract for vulnerabilities.\n2) Classify each vulnerability using DASP categories (e.g., reentrancy, access_control, arithmetic).\n3) Return ONLY valid JSON that matches the schema below.\n4) If no issues are found, return [].\n\nSchema (informal):\n- Array of objects with keys:\n  category, title, severity, confidence, evidence{file, lines, function}, explanation, fix_suggestion\n\nContract:\n```solidity\n/*\n * @source: etherscan.io \n * @author: -\n \n */\n\n//DAO Polska Token deployment\npragma solidity ^0.4.11;\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\n// title Migration Agent interface\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract ERC20 {\n  uint public totalSupply;\n  function balanceOf(address who) constant returns (uint);\n  function allowance(address owner, address spender) constant returns (uint);\n\n  function transfer(address to, uint value) returns (bool ok);\n  function transferFrom(address from, address to, uint value) returns (bool ok);\n  function approve(address spender, uint value) returns (bool ok);\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n/**\n * Math operations with safety checks\n */\ncontract SafeMath {\n  function safeMul(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function safeDiv(uint a, uint b) internal returns (uint) {\n    assert(b > 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function safeSub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function safeAdd(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  }\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function assert(bool assertion) internal {\n    if (!assertion) {\n      throw;\n    }\n  }\n}\n\n/**\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n *\n * Based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, SafeMath {\n\n  /* Token supply got increased and a new owner received these tokens */\n  event Minted(address receiver, uint amount);\n\n  /* Actual balances of token holders */\n  mapping(address => uint) balances;\n  // what exaclt ether was sent\n  mapping(address => uint) balancesRAW;\n  /* approve() allowances */\n  mapping (address => mapping (address => uint)) allowed;\n\n  /* Interface declaration */\n  function isToken() public constant returns (bool weAre) {\n    return true;\n  }\n\n  function transfer(address _to, uint _value) returns (bool success) {\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n    balances[_to] = safeAdd(balances[_to], _value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n    uint _allowance = allowed[_from][msg.sender];\n\n    balances[_to] = safeAdd(balances[_to], _value);\n    balances[_from] = safeSub(balances[_from], _value);\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n  function approve(address _spender, uint _value) returns (bool success) {\n\n    // To change the approve amount you first have to reduce the addresses`\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}\n\n//  daoPOLSKAtokens\ncontract daoPOLSKAtokens{\n\n    string public name = \"DAO POLSKA TOKEN version 1\";\n    string public symbol = \"DPL\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETC/ETH/HEE.\n\n    // Receives \n    address public owner;\n    address public migrationMaster;\t\n    // The current total token supply.\n\n    uint256 public otherchainstotalsupply =1.0 ether;\n    uint256 public supplylimit      = 10000.0 ether;\n\t//totalSupply   \n   uint256 public  totalSupply      = 0.0 ether;\n\t//chains:\n\taddress public Chain1 = 0x0;\n\taddress public Chain2 = 0x0;\n\taddress public Chain3 = 0x0;\n\taddress public Chain4 = 0x0;\n\n\taddress public migrationAgent=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;\n    uint256 public totalMigrated;\n\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n\tstruct sendTokenAway{\n\t\tStandardToken coinContract;\n\t\tuint amount;\n\t\taddress recipient;\n\t}\n\tmapping(uint => sendTokenAway) transfers;\n\tuint numTransfers=0;\n\t\n  mapping (address => uint256) balances;\nmapping (address => uint256) balancesRAW;\n  mapping (address => mapping (address => uint256)) allowed;\n\n\tevent UpdatedTokenInformation(string newName, string newSymbol);\t\n \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent receivedEther(address indexed _from,uint256 _value);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n      // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n  //tokenCreationCap\n  bool public supplylimitset = false;\n  bool public otherchainstotalset = false;\n   \n  function daoPOLSKAtokens() {\nowner=msg.sender;\nmigrationMaster=msg.sender;\n}\n\nfunction  setSupply(uint256 supplyLOCKER) public {\n    \t   if (msg.sender != owner) {\n      throw;\n    }\n\t\t    \t   if (supplylimitset != false) {\n      throw;\n    }\n\tsupplylimitset = true;\n  \n\tsupplylimit = supplyLOCKER ** uint256(decimals);\n//balances[owner]=supplylimit;\n  } \nfunction setotherchainstotalsupply(uint256 supplyLOCKER) public {\n    \t   if (msg.sender != owner) {\n      throw;\n    }\n\t    \t   if (supplylimitset != false) {\n      throw;\n    }\n\n\totherchainstotalset = true;\n\totherchainstotalsupply = supplyLOCKER ** uint256(decimals);\n\t\n  } \n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\n        balances[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balances[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowed[_from][msg.sender]);    // Check allowance\n        balances[_from] -= _value;                         // Subtract from the targeted balance\n        allowed[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n  \n  function transfer(address _to, uint256 _value) returns (bool success) {\n    //Default assumes totalSupply can't be over max (2^256 - 1).\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n    //Replace the if with this one instead.\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n    //if (balances[msg.sender] >= _value && _value > 0) {\n      balances[msg.sender] -= _value;\n      balances[_to] += _value;\n      Transfer(msg.sender, _to, _value);\n      return true;\n    } else { return false; }\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n    //same as above. Replace this line with the following if you want to protect against wrapping uints.\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n      balances[_to] += _value;\n      balances[_from] -= _value;\n      allowed[_from][msg.sender] -= _value;\n      Transfer(_from, _to, _value);\n      return true;\n    } else { return false; }\n  }\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  function approve(address _spender, uint256 _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n\t    function () payable  public {\n\t\t if(funding){ \n        receivedEther(msg.sender, msg.value);\n\t\tbalances[msg.sender]=balances[msg.sender]+msg.value;\n\t\t} else throw;\n\t\t\n    }\n\n  function setTokenInformation(string _name, string _symbol) {\n    \n\t   if (msg.sender != owner) {\n      throw;\n    }\n\tname = _name;\n    symbol = _symbol;\n\n    UpdatedTokenInformation(name, symbol);\n  }\n\nfunction setChainsAddresses(address chainAd, int chainnumber) {\n    \n\t   if (msg.sender != owner) {\n      throw;\n    }\n\tif(chainnumber==1){Chain1=chainAd;}\n\tif(chainnumber==2){Chain2=chainAd;}\n\tif(chainnumber==3){Chain3=chainAd;}\n\tif(chainnumber==4){Chain4=chainAd;}\t\t\n  } \n\n  function DAOPolskaTokenICOregulations() external returns(string wow) {\n\treturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\n}\n// if accidentally other token was donated to Project Dev\n\n\tfunction sendTokenAw(address StandardTokenAddress, address receiver, uint amount){\n\t\tif (msg.sender != owner) {\n\t\tthrow;\n\t\t}\n\t\tsendTokenAway t = transfers[numTransfers];\n\t\tt.coinContract = StandardToken(StandardTokenAddress);\n\t\tt.amount = amount;\n\t\tt.recipient = receiver;\n\t\tt.coinContract.transfer(receiver, amount);\n\t\tnumTransfers++;\n\t}\n\n     // Crowdfunding:\nuint public tokenCreationRate=1000;\nuint public bonusCreationRate=1000;\nuint public CreationRate=1761;\n   uint256 public constant oneweek = 36000;\nuint256 public fundingEndBlock = 5433616;\nbool public funding = true;\nbool public refundstate = false;\nbool public migratestate= false;\n        function createDaoPOLSKAtokens(address holder) payable {\n\n        if (!funding) throw;\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) throw;\n\t\t// check the maximum token creation cap\n        if (msg.value > (supplylimit - totalSupply) / CreationRate)\n          throw;\n\t\t\n\t\t//bonus structure\n// in early stage there is about 100% more details in ico regulations on website\n// price and converstion rate in tabled to PLN not ether, and is updated daily\n\n\t var numTokensRAW = msg.value;\n\n        var numTokens = msg.value * CreationRate;\n        totalSupply += numTokens;\n\n        // Assign new tokens to the sender\n        balances[holder] += numTokens;\n        balancesRAW[holder] += numTokensRAW;\n        // Log token creation event\n        Transfer(0, holder, numTokens);\n\t\t\n\t\t// Create additional Dao Tokens for the community and developers around 12%\n        uint256 percentOfTotal = 12;\n        uint256 additionalTokens = \tnumTokens * percentOfTotal / (100);\n\n        totalSupply += additionalTokens;\n\n        balances[migrationMaster] += additionalTokens;\n        Transfer(0, migrationMaster, additionalTokens);\n\t\n\t}\n\tfunction setBonusCreationRate(uint newRate){\n\tif(msg.sender == owner) {\n\tbonusCreationRate=newRate;\n\tCreationRate=tokenCreationRate+bonusCreationRate;\n\t}\n\t}\n\n    function FundsTransfer() external {\n\tif(funding==true) throw;\n\t\t \tif (!owner.send(this.balance)) throw;\n    }\n\t\n    function PartialFundsTransfer(uint SubX) external {\n\t      if (msg.sender != owner) throw;\n        \n        owner.send(this.balance - SubX);\n\t}\n\tfunction turnrefund() external {\n\t      if (msg.sender != owner) throw;\n\trefundstate=!refundstate;\n        }\n\t\t\n\t\t\tfunction fundingState() external {\n\t      if (msg.sender != owner) throw;\n\tfunding=!funding;\n        }\n    function turnmigrate() external {\n\t      if (msg.sender != migrationMaster) throw;\n\tmigratestate=!migratestate;\n}\n\n    // notice Finalize crowdfunding clossing funding options\n\t\nfunction finalize() external {\n        if (block.number <= fundingEndBlock+8*oneweek) throw;\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\t\n\t\trefundstate=!refundstate;\n        // Transfer ETH to theDAO Polska Token network Storage address.\n        if (msg.sender==owner)\n        \n\t\towner.send(this.balance);\n    }\n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (migratestate) throw;\n\n        // Validate input value.\n        if (_value == 0) throw;\n        if (_value > balances[msg.sender]) throw;\n\n        balances[msg.sender] -= _value;\n        totalSupply -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\t\nfunction refundTRA() external {\n        // Abort if not in Funding Failure state.\n        if (funding) throw;\n        if (!refundstate) throw;\n\n        var DAOPLTokenValue = balances[msg.sender];\n        var ETHValue = balancesRAW[msg.sender];\n        if (ETHValue == 0) throw;\n        balancesRAW[msg.sender] = 0;\n        totalSupply -= DAOPLTokenValue;\n         \n        Refund(msg.sender, ETHValue);\n        msg.sender.transfer(ETHValue);\n}\n\nfunction preICOregulations() external returns(string wow) {\n\treturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\n}\n\n}\n\n//------------------------------------------------------\n```",
    "api_calls": 1,
    "latency_s": 35.92221665382385,
    "prompt_tokens": 3875,
    "completion_tokens": 4207,
    "total_tokens": 8082,
    "cost_usd": 0.022773300000000003
  }
}