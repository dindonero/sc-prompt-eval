{
  "findings": [
    {
      "title": "Lottery outcome derived from manipulable block.blockhash",
      "category": "bad_randomness",
      "severity": "medium",
      "confidence": 0.5,
      "evidence": {
        "file": "contract.sol",
        "lines": [
          218,
          243,
          268,
          305,
          312
        ],
        "function": "betOf / won"
      },
      "explanation": "The contract uses block.blockhash (and concatenated stored hashes based on block.blockhash) to compute lottery outcomes. Miners can influence or predict blockhash values, allowing them to bias results in their favor or force reverts until a desired outcome is found, undermining lottery fairness.",
      "fix_suggestion": "",
      "key_variables": [],
      "key_statements": [],
      "scenario_matched": "",
      "property_verified": "",
      "static_check_type": "",
      "source": "",
      "static_confirmed": null,
      "static_check_reason": ""
    }
  ],
  "parse_errors": [],
  "finding_count": 1,
  "ground_truth": [
    {
      "category": "bad_randomness",
      "lines": [
        523
      ],
      "title": "Bad Randomness"
    },
    {
      "category": "bad_randomness",
      "lines": [
        560
      ],
      "title": "Bad Randomness"
    },
    {
      "category": "bad_randomness",
      "lines": [
        700
      ],
      "title": "Bad Randomness"
    },
    {
      "category": "bad_randomness",
      "lines": [
        702
      ],
      "title": "Bad Randomness"
    },
    {
      "category": "bad_randomness",
      "lines": [
        704
      ],
      "title": "Bad Randomness"
    },
    {
      "category": "bad_randomness",
      "lines": [
        706
      ],
      "title": "Bad Randomness"
    },
    {
      "category": "bad_randomness",
      "lines": [
        708
      ],
      "title": "Bad Randomness"
    },
    {
      "category": "bad_randomness",
      "lines": [
        710
      ],
      "title": "Bad Randomness"
    },
    {
      "category": "bad_randomness",
      "lines": [
        712
      ],
      "title": "Bad Randomness"
    },
    {
      "category": "bad_randomness",
      "lines": [
        714
      ],
      "title": "Bad Randomness"
    },
    {
      "category": "bad_randomness",
      "lines": [
        716
      ],
      "title": "Bad Randomness"
    },
    {
      "category": "bad_randomness",
      "lines": [
        718
      ],
      "title": "Bad Randomness"
    }
  ],
  "metrics": {
    "category_metrics": {
      "precision": 1.0,
      "recall": 1.0,
      "f1": 1.0,
      "tp": 1,
      "fp": 0,
      "fn": 0,
      "pred_categories": [
        "bad_randomness"
      ],
      "gt_categories": [
        "bad_randomness"
      ],
      "matched_categories": [
        "bad_randomness"
      ],
      "missed_categories": [],
      "spurious_categories": [],
      "unknown_predictions": 0
    },
    "instance_metrics": {
      "precision": 0.0,
      "recall": 0.0,
      "f1": 0.0,
      "tp": 0,
      "fp": 1,
      "fn": 12,
      "matched_instances": [],
      "unmatched_predictions": [
        {
          "category": "bad_randomness",
          "lines": [
            268,
            305,
            243,
            312,
            218
          ],
          "title": "Lottery outcome derived from manipulable block.blockhash"
        }
      ],
      "unmatched_ground_truth": [
        {
          "category": "bad_randomness",
          "lines": [
            523
          ]
        },
        {
          "category": "bad_randomness",
          "lines": [
            560
          ]
        },
        {
          "category": "bad_randomness",
          "lines": [
            700
          ]
        },
        {
          "category": "bad_randomness",
          "lines": [
            702
          ]
        },
        {
          "category": "bad_randomness",
          "lines": [
            704
          ]
        },
        {
          "category": "bad_randomness",
          "lines": [
            706
          ]
        },
        {
          "category": "bad_randomness",
          "lines": [
            708
          ]
        },
        {
          "category": "bad_randomness",
          "lines": [
            710
          ]
        },
        {
          "category": "bad_randomness",
          "lines": [
            712
          ]
        },
        {
          "category": "bad_randomness",
          "lines": [
            714
          ]
        },
        {
          "category": "bad_randomness",
          "lines": [
            716
          ]
        },
        {
          "category": "bad_randomness",
          "lines": [
            718
          ]
        }
      ],
      "has_line_annotations": true
    },
    "precision": 1.0,
    "recall": 1.0,
    "f1": 1.0,
    "tp": 1,
    "fp": 0,
    "fn": 0,
    "pred_categories": [
      "bad_randomness"
    ],
    "gt_categories": [
      "bad_randomness"
    ],
    "matched_categories": [
      "bad_randomness"
    ],
    "missed_categories": [],
    "spurious_categories": [],
    "unknown_predictions": 0
  },
  "loc": {
    "loc_total": 772,
    "loc_code": 527,
    "loc_comments": 168,
    "loc_blank": 77
  },
  "runner_metadata": {
    "approach": "smartguard_icl",
    "components": [
      "rag",
      "icl",
      "cot",
      "selfcheck"
    ],
    "demonstration_expansion": {
      "enabled": true,
      "patterns_expanded": 5,
      "cot_api_calls": 36,
      "cot_tokens": 75750,
      "cot_cost_usd": 0.2597133
    },
    "selfcheck": {
      "enabled": true,
      "iterations": 3,
      "converged": false,
      "convergence_iteration": null,
      "initial_findings": 2,
      "final_findings": 1,
      "findings_removed": 1,
      "iteration_history": [
        {
          "iteration": 1,
          "input_count": 2,
          "output_count": 2,
          "convergence_metrics": {
            "similarity": 0.3333333333333333,
            "added": [
              "denial_of_service:commitdividend / transfer / transferfrom:gas-exhaustion_in_commitdivide"
            ],
            "removed": [
              "denial_of_service:commitdividend / transfer:gas-exhaustion_in_commitdivide"
            ],
            "intersection_size": 1,
            "union_size": 3
          },
          "cost": 0.0212916,
          "tokens": 10197,
          "parse_errors": []
        },
        {
          "iteration": 2,
          "input_count": 2,
          "output_count": 1,
          "convergence_metrics": {
            "similarity": 0.5,
            "added": [],
            "removed": [
              "denial_of_service:commitdividend / transfer / transferfrom:gas-exhaustion_in_commitdivide"
            ],
            "intersection_size": 1,
            "union_size": 2
          },
          "cost": 0.0161315,
          "tokens": 8968,
          "parse_errors": []
        },
        {
          "iteration": 3,
          "input_count": 2,
          "output_count": 1,
          "convergence_metrics": {
            "similarity": 0.5,
            "added": [],
            "removed": [
              "denial_of_service:commitdividend / transfer / transferfrom:gas-exhaustion_in_commitdivide"
            ],
            "intersection_size": 1,
            "union_size": 2
          },
          "cost": 0.0225951,
          "tokens": 10425,
          "parse_errors": []
        }
      ]
    },
    "num_patterns_retrieved": 5,
    "retrieved_categories": [
      "arithmetic",
      "unchecked_low_level_calls",
      "reentrancy",
      "denial_of_service",
      "denial_of_service"
    ],
    "parse_errors": [],
    "raw_output": "```json\n[\n  {\n    \"category\": \"denial_of_service\",\n    \"title\": \"Gas-exhaustion in commitDividend loop can lock token operations\",\n    \"evidence\": {\n      \"file\": \"contract.sol\",\n      \"lines\": [52, 55, 60, 187, 198, 199],\n      \"function\": \"commitDividend / transfer\"\n    },\n    \"explanation\": \"The internal commitDividend function iterates over every unclaimed dividend period in a for-loop (lines 187\u2013205). It is invoked on every transfer (lines 52, 55 & 60) and on other operations. If a user has not claimed dividends for many periods, the loop can grow large enough to exceed the block gas limit. Once any call to commitDividend runs out of gas it reverts, preventing transfers, transferFrom and other operations for that user. In effect, token-holders who defer claiming dividends become permanently unable to move or redeem their tokens, causing a denial-of-service on their funds.\"\n  },\n  {\n    \"category\": \"bad_randomness\",\n    \"title\": \"Lottery outcome derived from manipulable block.blockhash\",\n    \"evidence\": {\n      \"file\": \"contract.sol\",\n      \"lines\": [213, 218, 222, 236, 243],\n      \"function\": \"betOf / won\"\n    },\n    \"explanation\": \"The contract decides lottery results by XOR\u2019ing the user\u2019s betHash with block.blockhash(player.blockNum) (lines 218 & 243), or with a stored variant via getHash. Because blockhash values for a known future block can be influenced by the miner (through block assembly and timestamp choices) and are publicly predictable once mined, miners can bias or outright manipulate the outcome in their favor. Reliance on block.blockhash for randomness compromises the fairness and security of the lottery.\"\n  }\n]\n```",
    "rendered_prompt": "## SMART CONTRACT SECURITY AUDIT WITH LEARNED EXAMPLES\n\nYou are a security auditor specializing in Solidity smart contracts. Below are examples of vulnerable contracts with detailed security analysis. **Learn from these examples** to analyze the target contract.\n\n---\n\n## IN-CONTEXT LEARNING EXAMPLES\n\nThe following are examples of real vulnerabilities with expert analysis. Study how the vulnerabilities are identified and explained, then apply the same analytical approach to the target contract.\n\n### EXAMPLE 1: ARITHMETIC VULNERABILITY\n\n**Vulnerable Code:**\n```solidity\npragma solidity ^0.4.18;\n\n\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public constant returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n   \n  modifier onlyPayloadSize(uint size) {\n     require(msg.data.length >= size + 4);\n     _;\n  }\n\n  \n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32)  public returns (bool) {\n    require (_to != address(0));\n    require (_value > 0);\n    require (balances[msg.sender] >= _value); \n    \n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  \n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) allowed;\n\n\n  \n  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32)  public returns (bool) {\n    require(_to != address(0));\n    require (_value > 0);\n    require (balances[_from] >= _value); \n    \n    require (_value <= allowed[_from][msg.sender]); \n\n    uint256 _allowance = allowed[_from][msg.sender];\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  \n  function approve(address _spender, uint256 _value) public returns (bool) {\n  \trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  \n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}\n\n\n\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  \n  function Ownable() {\n    owner = msg.sender;\n  }\n\n  \n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  \n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n    \n    uint256 c = a / b;\n    \n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n\n\n\ncontract MagnaChain is StandardToken, Ownable{\n    \n    string public version = \"1.0\";\n    string public name = \"MagnaChain\";\n    string public symbol = \"MGC\";\n    uint8 public  decimals = 18;\n\n    mapping(address=>uint256)  lockedBalance;\n    mapping(address=>uint)     timeRelease; \n    \n    uint256 internal constant INITIAL_SUPPLY = 20 * 100 * (10**6) * (10 **18);\n    uint256 internal constant MAX_TIME = 60*60*24*365*5;\n\n    event Burn(address indexed burner, uint256 value);\n    event Lock(address indexed locker, uint256 value, uint releaseTime);\n    event \n```\n\n**Security Analysis:**\nHere is a concise, step-by-step explanation of the issue, why it can actually be exploited, and how to fix it:\n\n1) Vulnerable pattern  \n   ```solidity\n   uint256 public constant MAX_TIME = 60*60*24*365*5;  // \u201c5-year\u201d cap, never enforced\n   mapping(address => uint256) public lockedBalance;\n   mapping(address => uint256) public timeRelease;\n\n   function lock(uint256 _value, uint256 _duration) public {\n     // \u274c Unchecked addition: no SafeMath and no require on _duration\n     timeRelease[msg.sender] = now + _duration;\n     lockedBalance[msg.sender] += _value;\n     balances[msg.sender] -= _value;\n     Lock(msg.sender, _value, timeRelease[msg.sender]);\n   }\n\n   function release() public {\n     require(now >= timeRelease[msg.sender]);\n     uint256 value = lockedBalance[msg.sender];\n     lockedBalance[msg.sender] = 0;\n     balances[msg.sender] += value;\n   }\n   ```\n\n2) How the wrap-around attack works  \n   - Solidity\u2019s unsigned integers wrap around modulo 2^256.  \n   - The contract does not use `SafeMath.add(now, _duration)`, nor does it enforce `_duration <= MAX_TIME`.  \n   - An attacker picks  \n       _duration \u2265 2^256 \u2212 now  \n     so that  \n       now + _duration  \u2261  (now + _duration) mod 2^256  \n     becomes a small value (in fact \u2264 now).  \n   - As soon as `lock(...)` finishes, `timeRelease[msg.sender]` is already in the past, so `release()`\u2019s `require(now >= timeRelease[msg.sender])` immediately passes. The \u201clock\u201d is meaningless.\n\n3) Conditions for exploitation  \n   \u2013 Unchecked addition of user-supplied `_duration` to `now`.  \n   \u2013 No `require(_duration <= MAX_TIME)`.  \n   \u2013 No SafeMath guard on that addition.  \n   \u2013 Attacker simply submits a huge `_duration` to force the wrap-around.\n\n4) How to fix it  \n   Option A (SafeMath guard):  \n     timeRelease[msg.sender] = SafeMath.add(now, _duration);  \n   Option B (hard cap + SafeMath or native check):  \n     require(_duration <= MAX_TIME);  \n     timeRelease[msg.sender] = now + _duration;  \n   Either approach prevents the overflow and/or enforces your intended maximum lock period.\n\nSummary  \nBy mixing unchecked arithmetic with a user-supplied duration, the contract allows an attacker to wrap the timestamp around to the past and immediately withdraw locked tokens. Always either bound user inputs before you operate on them, or use a checked\u2010arithmetic library like SafeMath for every single addition or multiplication.\n\n\n**Classification**: This code contains a **arithmetic** vulnerability.\n\n---\n\n### EXAMPLE 2: UNCHECKED_LOW_LEVEL_CALLS VULNERABILITY\n\n**Vulnerable Code:**\n```solidity\npragma solidity ^0.4.19;\n\ncontract Ownable {\n  address public owner;\n\n\n  /** \n   *\n   * account.\n   */\n  function Ownable() internal {\n    owner = msg.sender;\n  }\n\n\n  /**\n   *\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   *\n   *\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    owner = newOwner;\n  }\n\n}\n\n/**\n * Interface for the standard token.\n * Based on https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n */\ninterface EIP20Token {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address who) external view returns (uint256);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n// The owner of this contract should be an externally owned account\ncontract HumanProtocolInvestment is Ownable {\n\n  // Address of the target contract\n  address public investment_address = 0x55704E8Cb15AF1054e21a7a59Fb0CBDa6Bd044B7;\n  // Major partner address\n  address public major_partner_address = 0x5a89D9f1C382CaAa66Ee045aeb8510F1205bC8bf;\n  // Minor partner address\n  address public minor_partner_address = 0xC787C3f6F75D7195361b64318CE019f90507f806;\n  // Third partner address\n  address public third_partner_address = 0xDa2cEa3DbaC30835D162Df11D21Ac6Cbf355aC9F;\n  // Additional gas used for transfers.\n  uint public gas = 1000;\n\n  // Payments to this contract require a bit of gas. 100k should be enough.\n  function() payable public {\n    execute_transfer(msg.value);\n  }\n\n  // Transfer some funds to the target investment address.\n  function execute_transfer(uint transfer_amount) internal {\n    // Major fee is 30% * (1/11) * value = 3 * value / (10 * 11)\n    uint major_fee = transfer_amount * 3 / (10 * 11);\n    // Minor fee is 20% * (1/11) * value = 2 * value / (10 * 11)\n    uint minor_fee = transfer_amount * 2 / (10 * 11);\n    // Third fee is 50% * (1/11) * value = 5 * value / (10 * 11)\n    uint third_fee = transfer_amount * 5 / (10 * 11);\n\n    require(major_partner_address.call.gas(gas).value(major_fee)());\n    require(minor_partner_address.call.gas(gas).value(minor_fee)());\n    require(third_partner_address.call.gas(gas).value(third_fee)());\n\n    // Send the rest\n    uint investment_amount = transfer_amount - major_fee - minor_fee - third_fee;\n    require(investment_address.call.gas(gas).value(investment_amount)());\n  }\n\n  // Sets the amount of additional gas allowed to addresses called\n  // @dev This allows transfers to multisigs that use more than 2300 gas in their fallback function.\n  //  \n  function set_transfer_gas(uint transfer_gas) public onlyOwner {\n    gas = transfer_gas;\n  }\n\n  // We can use this function to move unwanted tokens in the contract\n  function approve_unwanted_tokens(EIP20Token token, address dest, uint value) public onlyOwner {\n    token.approve(dest, value);\n  }\n\n  // This contract is designed to have no balance.\n  // However, we include this function to avoid stuck value by some unknown mishap.\n  function emergency_withdraw() public onlyOwner {\n    require(msg.sender.call.gas(gas).value(this.balance)());\n  }\n\n}\n```\n\n**Security Analysis:**\nThis code contains a unchecked_low_level_calls vulnerability.\n\nHere\u2019s a concise, refined summary of the issue and why it matters:\n\n1) What\u2019s actually happening  \n   \u2022 The contract sends ETH or interacts with tokens via low-level calls (e.g.  \n     major_partner.call.gas(gas).value(major_fee)(),  \n     msg.sender.call.gas(gas).value(this.balance)()  \n     token.approve(...) without checking the return value)  \n   \u2022 Low-level CALL never throws on failure\u2014it simply returns false if the callee\u2019s fallback reverts or runs out of gas.\n\n2) Why it\u2019s dangerous  \n   a) Denial-of-Service (DOS) on deposits  \n      \u2013 You wrap each partner payment in require(), so if any partner\u2019s fallback reverts (malicious or out-of-gas), you revert the entire deposit.  \n      \u2013 A single malicious partner can block everyone from ever depositing again.  \n   b) Stuck funds on emergency withdrawal or token recovery  \n      \u2013 Your emergency_withdraw uses a low-level call with a fixed gas stipend; if the owner\u2019s fallback needs more gas, withdraw silently fails under require(), leaving ETH locked.  \n      \u2013 Your token recovery doesn\u2019t check token.approve\u2019s return value, so a \u201cfalse\u201d return means no approval\u2014and the tokens remain stuck.\n\n3) Preconditions for an exploit  \n   \u2022 The target address must be a contract, not an EOA.  \n   \u2022 Its fallback or receive function must either revert unconditionally or deliberately consume more gas than you forwarded.  \n   \u2022 You must be using .call(\u2026) (or similar) without robustly handling the boolean return.\n\n4) How to fix it  \n   \u2022 Always check the boolean return of every low-level call:  \n       bool ok = partner.call{gas: g, value: v}();  \n       require(ok, \"payment failed\");  \n   \u2022 Prefer higher-level methods that revert automatically:  \n     \u2013 In Solidity <0.6 use address.transfer(amount) (2300 gas)  \n     \u2013 In Solidity \u22650.6 use OpenZeppelin\u2019s Address.sendValue(amount)  \n   \u2022 For ERC-20 calls always assert the returned bool:  \n       require(token.transfer(to, amount), \"ERC20 transfer failed\");  \n\nBy following these rules you eliminate both the DOS risk (partner-triggered revert) and the silent-failure risk (unchecked .call or token return), ensuring your funds can never get stuck and that failures always bubble up clearly.\n\n\n**Classification**: This code contains a **unchecked_low_level_calls** vulnerability.\n\n---\n\n### EXAMPLE 3: REENTRANCY VULNERABILITY\n\n**Vulnerable Code:**\n```solidity\npragma solidity ^0.4.19;\n\ncontract Ownable {\n  address public owner;\n\n\n  /** \n   *\n   * account.\n   */\n  function Ownable() internal {\n    owner = msg.sender;\n  }\n\n\n  /**\n   *\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   *\n   *\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    owner = newOwner;\n  }\n\n}\n\n/**\n * Interface for the standard token.\n * Based on https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n */\ninterface EIP20Token {\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address who) external view returns (uint256);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n// The owner of this contract should be an externally owned account\ncontract HumanProtocolInvestment is Ownable {\n\n  // Address of the target contract\n  address public investment_address = 0x55704E8Cb15AF1054e21a7a59Fb0CBDa6Bd044B7;\n  // Major partner address\n  address public major_partner_address = 0x5a89D9f1C382CaAa66Ee045aeb8510F1205bC8bf;\n  // Minor partner address\n  address public minor_partner_address = 0xC787C3f6F75D7195361b64318CE019f90507f806;\n  // Third partner address\n  address public third_partner_address = 0xDa2cEa3DbaC30835D162Df11D21Ac6Cbf355aC9F;\n  // Additional gas used for transfers.\n  uint public gas = 1000;\n\n  // Payments to this contract require a bit of gas. 100k should be enough.\n  function() payable public {\n    execute_transfer(msg.value);\n  }\n\n  // Transfer some funds to the target investment address.\n  function execute_transfer(uint transfer_amount) internal {\n    // Major fee is 30% * (1/11) * value = 3 * value / (10 * 11)\n    uint major_fee = transfer_amount * 3 / (10 * 11);\n    // Minor fee is 20% * (1/11) * value = 2 * value / (10 * 11)\n    uint minor_fee = transfer_amount * 2 / (10 * 11);\n    // Third fee is 50% * (1/11) * value = 5 * value / (10 * 11)\n    uint third_fee = transfer_amount * 5 / (10 * 11);\n\n    require(major_partner_address.call.gas(gas).value(major_fee)());\n    require(minor_partner_address.call.gas(gas).value(minor_fee)());\n    require(third_partner_address.call.gas(gas).value(third_fee)());\n\n    // Send the rest\n    uint investment_amount = transfer_amount - major_fee - minor_fee - third_fee;\n    require(investment_address.call.gas(gas).value(investment_amount)());\n  }\n\n  // Sets the amount of additional gas allowed to addresses called\n  // @dev This allows transfers to multisigs that use more than 2300 gas in their fallback function.\n  //  \n  function set_transfer_gas(uint transfer_gas) public onlyOwner {\n    gas = transfer_gas;\n  }\n\n  // We can use this function to move unwanted tokens in the contract\n  function approve_unwanted_tokens(EIP20Token token, address dest, uint value) public onlyOwner {\n    token.approve(dest, value);\n  }\n\n  // This contract is designed to have no balance.\n  // However, we include this function to avoid stuck value by some unknown mishap.\n  function emergency_withdraw() public onlyOwner {\n    require(msg.sender.call.gas(gas).value(this.balance)());\n  }\n\n}\n```\n\n**Security Analysis:**\nThis code contains a reentrancy vulnerability.\n\nHere is a concise, accurate and complete restatement of the issue, the exploit and the conditions that make it possible\u2014plus the safest remedies.\n\n1) Vulnerable pattern in execute_transfer()  \n   \u2022 The contract splits an incoming payment into three \u201cpartner fees\u201d and one \u201cinvestment amount.\u201d  \n   \u2022 It pays each partner via  \n       require(partner.call.gas(gas).value(fee)());  \n     before ever recording that those fees were paid or otherwise locking the contract\u2019s state.  \n   \u2022 Only after all three partner calls does it forward the leftover to the investment address.  \n   \u2022 There is no re-entrancy guard or state flag (\u201cchecks\u2010effects\u2010interactions\u201d is violated), and the partner addresses are assumed trusted\u2014but they can be contracts.\n\n2) How an attacker exploits this  \n   \u2022 The attacker deploys a malicious partner contract with a payable fallback that immediately calls back into the victim:  \n     function() payable { victim.call.value(0)(); }  \n   \u2022 A normal user (or the attacker) sends 100 ETH to the victim. Inside execute_transfer():  \n     \u2013 major_fee \u2248 2.7272 ETH gets sent first  \n     \u2013 control flows into attacker\u2019s fallback *before* any state change or the final 90.9093 ETH is sent to the real investment address  \n     \u2013 attacker\u2019s fallback does victim.call.value(0)(), re-entering execute_transfer() mid-flight  \n   \u2022 Each re-entry repeats the same sequence of partner .call.value(\u2026) calls, but the final investment transfer is still postponed. By looping or nesting enough re-entries (even with zero-value calls), the attacker can keep the contract from ever completing the \u201csend to investment\u201d step and siphon off more funds.\n\n3) Why this works  \n   \u2022 .call.value(...).gas(...) forwards essentially unlimited gas, so the fallback can recurse.  \n   \u2022 No mutex or nonReentrant modifier is in place.  \n   \u2022 No state update \u201cmarks\u201d that fees have already been distributed.  \n   \u2022 At least one partner address is a contract under the attacker\u2019s control with a payable fallback.\n\n4) How to fix it  \n   \u2022 Follow Checks-Effects-Interactions: update your internal state (e.g. mark fees paid) *before* any external call.  \n   \u2022 Use transfer() or send() instead of call.value() if you want to limit the gas forwarded to 2,300 gas (making re-entry much harder).  \n   \u2022 Or add a re-entrancy guard (e.g. a bool locked with a nonReentrant modifier) around any function that makes external calls.  \n   \u2022 Consider a \u201cpull-over-push\u201d pattern: let recipients withdraw their funds rather than pushing payments inside your main logic.\n\nBy moving all state changes ahead of external calls, or by limiting gas/requiring a nonReentrant lock, you close the window that the attacker\u2019s fallback uses to re-enter and hijack the distribution.\n\n\n**Classification**: This code contains a **reentrancy** vulnerability.\n\n---\n\n### EXAMPLE 4: DENIAL_OF_SERVICE VULNERABILITY\n\n**Vulnerable Code:**\n```solidity\npragma solidity ^0.4.24;\n/**\n *\n *\n *\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) constant returns (uint256);\n  function transfer(address to, uint256 value) returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n/**\n *\n *\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) returns (bool);\n  function approve(address spender, uint256 value) returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n/**\n *\n *\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n  *\n  *\n  *\n  */\n  function transfer(address _to, uint256 _value) returns (bool) {\n    require(_to != address(0));\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  *\n  *\n  *\n  */\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n/**\n *\n *\n *\n *\n *\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) allowed;\n\n\n  /**\n   *\n   *\n   *\n   *\n   */\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n    require(_to != address(0));\n\n    var _allowance = allowed[_from][msg.sender];\n\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n    // require (_value <= _allowance);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   *\n   *\n   *\n   */\n  function approve(address _spender, uint256 _value) returns (bool) {\n\n    // To change the approve amount you first have to reduce the addresses`\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   *\n   *\n   *\n   *\n```\n\n**Security Analysis:**\nThis code contains a denial_of_service vulnerability.\n\nBelow is a concise, end-to-end explanation of exactly what goes wrong and how an attacker can use it to lock you out of changing your allowance forever:\n\n1) The Offending Code Pattern  \n   In your ERC-20 token\u2019s approve() you have this \u201czero-or-zero\u201d check meant to avoid the classic race condition:\n   ```\n   function approve(address _spender, uint256 _value) returns (bool) {\n     // Only allow setting a non-zero allowance if the old allowance is zero\n     require(\n       _value == 0\n       || allowed[msg.sender][_spender] == 0\n     );\n\n     allowed[msg.sender][_spender] = _value;\n     Approval(msg.sender, _spender, _value);\n     return true;\n   }\n   ```\n   That means you can never change a non-zero allowance directly to another non-zero value in one call. You must first call `approve(spender, 0)` and then `approve(spender, newValue)`.\n\n2) How an Attacker Freezes Your Allowance  \n   \u2013 Assume you originally did `approve(spender, 100)`. The spender can already pull up to 100.  \n   \u2013 You now want to bump your allowance to 150. A single call `approve(spender, 150)` will revert (because the old allowance isn\u2019t zero).  \n   \u2013 You attempt the two-step approach:\n\n     a) You send `approve(spender, 0)` to zero out the old 100.  \n     b) Before that tx is mined, the spender watches the mempool and frontruns you with `transferFrom(owner, attacker, 1)`, pulling just one token. Now the allowance in the pending state is 99.  \n     c) Your zero-out tx finally executes, but it sets the allowance from 99 to 0. Fine\u2014but the spender has already stolen that one token.  \n     d) You now call `approve(spender, 150)` to set the new allowance\u2014but this reverts again because the contract still sees a *non-zero* old allowance (they only left you 99 before your zero-out).  \n     e) You\u2019re stuck in a loop: every time you try to zero it out again, they pull or top-up allowance by frontrunning, so you never permanently clear the old allowance.\n\n3) Conditions Needed for the Denial-of-Service  \n   \u2022 The token uses `require(_value==0 || oldAllowance==0)` in approve.  \n   \u2022 The spender already has a non-zero allowance.  \n   \u2022 The spender can watch your zero-out tx in the mempool and frontrun with a tiny `transferFrom`.  \n\nResult: You can never move from \u201csome non-zero\u201d allowance to \u201csome new non-zero\u201d allowance, because your zero-out step keeps being subverted. The malicious spender effectively holds your approve list hostage forever.\n\nThis is not just a minor inconvenience\u2014it is a permanent denial-of-service on *changing* allowances for that spender.\n\n\n**Classification**: This code contains a **denial_of_service** vulnerability.\n\n---\n\n### EXAMPLE 5: DENIAL_OF_SERVICE VULNERABILITY\n\n**Vulnerable Code:**\n```solidity\npragma solidity ^0.4.24;\n/**\n *\n *\n *\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) constant returns (uint256);\n  function transfer(address to, uint256 value) returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n/**\n *\n *\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) returns (bool);\n  function approve(address spender, uint256 value) returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n/**\n *\n *\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n  *\n  *\n  *\n  */\n  function transfer(address _to, uint256 _value) returns (bool) {\n    require(_to != address(0));\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  *\n  *\n  *\n  */\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n/**\n *\n *\n *\n *\n *\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) allowed;\n\n\n  /**\n   *\n   *\n   *\n   *\n   */\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n    require(_to != address(0));\n\n    var _allowance = allowed[_from][msg.sender];\n\n    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n    // require (_value <= _allowance);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   *\n   *\n   *\n   */\n  function approve(address _spender, uint256 _value) returns (bool) {\n\n    // To change the approve amount you first have to reduce the addresses`\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   *\n   *\n   *\n   *\n```\n\n**Security Analysis:**\nThis code contains a denial_of_service vulnerability.\n\nBelow is a concise, end-to-end explanation of exactly what goes wrong and how an attacker can use it to lock you out of changing your allowance forever:\n\n1) The Offending Code Pattern  \n   In your ERC-20 token\u2019s approve() you have this \u201czero-or-zero\u201d check meant to avoid the classic race condition:\n   ```\n   function approve(address _spender, uint256 _value) returns (bool) {\n     // Only allow setting a non-zero allowance if the old allowance is zero\n     require(\n       _value == 0\n       || allowed[msg.sender][_spender] == 0\n     );\n\n     allowed[msg.sender][_spender] = _value;\n     Approval(msg.sender, _spender, _value);\n     return true;\n   }\n   ```\n   That means you can never change a non-zero allowance directly to another non-zero value in one call. You must first call `approve(spender, 0)` and then `approve(spender, newValue)`.\n\n2) How an Attacker Freezes Your Allowance  \n   \u2013 Assume you originally did `approve(spender, 100)`. The spender can already pull up to 100.  \n   \u2013 You now want to bump your allowance to 150. A single call `approve(spender, 150)` will revert (because the old allowance isn\u2019t zero).  \n   \u2013 You attempt the two-step approach:\n\n     a) You send `approve(spender, 0)` to zero out the old 100.  \n     b) Before that tx is mined, the spender watches the mempool and frontruns you with `transferFrom(owner, attacker, 1)`, pulling just one token. Now the allowance in the pending state is 99.  \n     c) Your zero-out tx finally executes, but it sets the allowance from 99 to 0. Fine\u2014but the spender has already stolen that one token.  \n     d) You now call `approve(spender, 150)` to set the new allowance\u2014but this reverts again because the contract still sees a *non-zero* old allowance (they only left you 99 before your zero-out).  \n     e) You\u2019re stuck in a loop: every time you try to zero it out again, they pull or top-up allowance by frontrunning, so you never permanently clear the old allowance.\n\n3) Conditions Needed for the Denial-of-Service  \n   \u2022 The token uses `require(_value==0 || oldAllowance==0)` in approve.  \n   \u2022 The spender already has a non-zero allowance.  \n   \u2022 The spender can watch your zero-out tx in the mempool and frontrun with a tiny `transferFrom`.  \n\nResult: You can never move from \u201csome non-zero\u201d allowance to \u201csome new non-zero\u201d allowance, because your zero-out step keeps being subverted. The malicious spender effectively holds your approve list hostage forever.\n\nThis is not just a minor inconvenience\u2014it is a permanent denial-of-service on *changing* allowances for that spender.\n\n\n**Classification**: This code contains a **denial_of_service** vulnerability.\n\n---\n\n\n## TARGET CONTRACT FOR ANALYSIS\n\nNow apply the same analytical approach demonstrated above to this contract:\n\n```solidity\n/*\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\n * @author: -\n \n */\n\npragma solidity ^0.4.13;\n\nlibrary SafeMath {\n  function sub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n  function add(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint public totalSupply;\n  address public owner; //owner\n  address public animator; //animator\n  function balanceOf(address who) constant returns (uint);\n  function transfer(address to, uint value);\n  event Transfer(address indexed from, address indexed to, uint value);\n  function commitDividend(address who) internal; // pays remaining dividend\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) constant returns (uint);\n  function transferFrom(address from, address to, uint value);\n  function approve(address spender, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n  mapping(address => uint) balances;\n\n  modifier onlyPayloadSize(uint size) {\n     assert(msg.data.length >= size + 4);\n     _;\n  }\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    commitDividend(msg.sender);\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    if(_to == address(this)) {\n        commitDividend(owner);\n        balances[owner] = balances[owner].add(_value);\n        Transfer(msg.sender, owner, _value);\n    }\n    else {\n        commitDividend(_to);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n    }\n  }\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\ncontract StandardToken is BasicToken, ERC20 {\n  mapping (address => mapping (address => uint)) allowed;\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint the amout of tokens to be transfered\n   */\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n    var _allowance = allowed[_from][msg.sender];\n    commitDividend(_from);\n    commitDividend(_to);\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n  /**\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint _value) {\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n  /**\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint specifing the amount of tokens still avaible for the spender.\n   */\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\n/**\n * @title SmartBillions contract\n */\ncontract SmartBillions is StandardToken {\n\n    // metadata\n    string public constant name = \"SmartBillions Token\";\n    string public constant symbol = \"PLAY\";\n    uint public constant decimals = 0;\n\n    // contract state\n    struct Wallet {\n        uint208 balance; // current balance of user\n    \tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\n    \tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\n    }\n    mapping (address => Wallet) wallets;\n    struct Bet {\n        uint192 value; // bet size\n        uint32 betHash; // selected numbers\n        uint32 blockNum; // blocknumber when lottery runs\n    }\n    mapping (address => Bet) bets;\n\n    uint public walletBalance = 0; // sum of funds in wallets\n\n    // investment parameters\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\n    uint public investBalance = 0; // funding from investors\n    uint public investBalanceMax = 200000 ether; // maximum funding\n    uint public dividendPeriod = 1;\n    uint[] public dividends; // dividens collected per period, growing array\n\n    // betting parameters\n    uint public maxWin = 0; // maximum prize won\n    uint public hashFirst = 0; // start time of building hashes database\n    uint public hashLast = 0; // last saved block of hashes\n    uint public hashNext = 0; // next available bet block.number\n    uint public hashBetSum = 0; // used bet volume of next block\n    uint public hashBetMax = 5 ether; // maximum bet size per block\n    uint[] public hashes; // space for storing lottery results\n\n    // constants\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\n\n    // events\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\n    event LogLoss(address indexed player, uint bethash, uint hash);\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\n    event LogRecordWin(address indexed player, uint amount);\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\n    event LogDividend(address indexed investor, uint amount, uint period);\n\n    modifier onlyOwner() {\n        assert(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyAnimator() {\n        assert(msg.sender == animator);\n        _;\n    }\n\n    // constructor\n    function SmartBillions() {\n        owner = msg.sender;\n        animator = msg.sender;\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\n        dividends.push(0); // not used\n        dividends.push(0); // current dividend\n    }\n\n/* getters */\n\n    /**\n     * @dev Show length of allocated swap space\n     */\n    function hashesLength() constant external returns (uint) {\n        return uint(hashes.length);\n    }\n\n    /**\n     * @dev Show balance of wallet\n     * @param _owner The address of the account.\n     */\n    function walletBalanceOf(address _owner) constant external returns (uint) {\n        return uint(wallets[_owner].balance);\n    }\n\n    /**\n     * @dev Show last dividend period processed\n     * @param _owner The address of the account.\n     */\n    function walletPeriodOf(address _owner) constant external returns (uint) {\n        return uint(wallets[_owner].lastDividendPeriod);\n    }\n\n    /**\n     * @dev Show block number when withdraw can continue\n     * @param _owner The address of the account.\n     */\n    function walletBlockOf(address _owner) constant external returns (uint) {\n        return uint(wallets[_owner].nextWithdrawBlock);\n    }\n\n    /**\n     * @dev Show bet size.\n     * @param _owner The address of the player.\n     */\n    function betValueOf(address _owner) constant external returns (uint) {\n        return uint(bets[_owner].value);\n    }\n\n    /**\n     * @dev Show block number of lottery run for the bet.\n     * @param _owner The address of the player.\n     */\n    function betHashOf(address _owner) constant external returns (uint) {\n        return uint(bets[_owner].betHash);\n    }\n\n    /**\n     * @dev Show block number of lottery run for the bet.\n     * @param _owner The address of the player.\n     */\n    function betBlockNumberOf(address _owner) constant external returns (uint) {\n        return uint(bets[_owner].blockNum);\n    }\n\n    /**\n     * @dev Print number of block till next expected dividend payment\n     */\n    function dividendsBlocks() constant external returns (uint) {\n        if(investStart > 0) {\n            return(0);\n        }\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\n        if(period > dividendPeriod) {\n            return(0);\n        }\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\n    }\n\n/* administrative functions */\n\n    /**\n     * @dev Change owner.\n     * @param _who The address of new owner.\n     */\n    function changeOwner(address _who) external onlyOwner {\n        assert(_who != address(0));\n        commitDividend(msg.sender);\n        commitDividend(_who);\n        owner = _who;\n    }\n\n    /**\n     * @dev Change animator.\n     * @param _who The address of new animator.\n     */\n    function changeAnimator(address _who) external onlyAnimator {\n        assert(_who != address(0));\n        commitDividend(msg.sender);\n        commitDividend(_who);\n        animator = _who;\n    }\n\n    /**\n     * @dev Set ICO Start block.\n     * @param _when The block number of the ICO.\n     */\n    function setInvestStart(uint _when) external onlyOwner {\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\n        investStart = _when;\n    }\n\n    /**\n     * @dev Set maximum bet size per block\n     * @param _maxsum The maximum bet size in wei.\n     */\n    function setBetMax(uint _maxsum) external onlyOwner {\n        hashBetMax = _maxsum;\n    }\n\n    /**\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\n     */\n    function resetBet() external onlyOwner {\n        hashNext = block.number + 3;\n        hashBetSum = 0;\n    }\n\n    /**\n     * @dev Move funds to cold storage\n     * @dev investBalance and walletBalance is protected from withdraw by owner\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\n     * @param _amount The amount of wei to move to cold storage\n     */\n    function coldStore(uint _amount) external onlyOwner {\n        houseKeeping();\n        require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount);\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\n            require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\n        }\n        msg.sender.transfer(_amount);\n        coldStoreLast = block.number;\n    }\n\n    /**\n     * @dev Move funds to contract jackpot\n     */\n    function hotStore() payable external {\n        houseKeeping();\n    }\n\n/* housekeeping functions */\n\n    /**\n     * @dev Update accounting\n     */\n    function houseKeeping() public {\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\n            investStart = 0; // start dividend payments\n        }\n        else {\n            if(hashFirst > 0){\n\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\n                if(period > dividends.length - 2) {\n                    dividends.push(0);\n                }\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\n                    dividendPeriod++;\n                }\n            }\n        }\n    }\n\n/* payments */\n\n    /**\n     * @dev Pay balance from wallet\n     */\n    function payWallet() public {\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\n            uint balance = wallets[msg.sender].balance;\n            wallets[msg.sender].balance = 0;\n            walletBalance -= balance;\n            pay(balance);\n        }\n    }\n\n    function pay(uint _amount) private {\n        uint maxpay = this.balance / 2;\n        if(maxpay >= _amount) {\n            msg.sender.transfer(_amount);\n            if(_amount > 1 finney) {\n                houseKeeping();\n            }\n        }\n        else {\n            uint keepbalance = _amount - maxpay;\n            walletBalance += keepbalance;\n            wallets[msg.sender].balance += uint208(keepbalance);\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\n            msg.sender.transfer(maxpay);\n        }\n    }\n\n/* investment functions */\n\n    /**\n     * @dev Buy tokens\n     */\n    function investDirect() payable external {\n        invest(owner);\n    }\n\n    /**\n     * @dev Buy tokens with affiliate partner\n     * @param _partner Affiliate partner\n     */\n    function invest(address _partner) payable public {\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\n        uint investing = msg.value;\n        if(investing > investBalanceMax - investBalance) {\n            investing = investBalanceMax - investBalance;\n            investBalance = investBalanceMax;\n            investStart = 0; // close investment round\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\n        }\n        else{\n            investBalance += investing;\n        }\n        if(_partner == address(0) || _partner == owner){\n            walletBalance += investing / 10;\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\n        else{\n            walletBalance += (investing * 5 / 100) * 2;\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\n        uint senderBalance = investing / 10**15;\n        uint ownerBalance = investing * 16 / 10**17  ;\n        uint animatorBalance = investing * 10 / 10**17  ;\n        balances[msg.sender] += senderBalance;\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\n        Transfer(address(0),msg.sender,senderBalance); // for etherscan\n        Transfer(address(0),owner,ownerBalance); // for etherscan\n        Transfer(address(0),animator,animatorBalance); // for etherscan\n        LogInvestment(msg.sender,_partner,investing);\n    }\n\n    /**\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\n     */\n    function disinvest() external {\n        require(investStart == 0);\n        commitDividend(msg.sender);\n        uint initialInvestment = balances[msg.sender] * 10**15;\n        Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\n        investBalance -= initialInvestment;\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\n        payWallet();\n    }\n\n    /**\n     * @dev Pay unpaid dividends\n     */\n    function payDividends() external {\n        require(investStart == 0);\n        commitDividend(msg.sender);\n        payWallet();\n    }\n\n    /**\n     * @dev Commit remaining dividends before transfer of tokens\n     */\n    function commitDividend(address _who) internal {\n        uint last = wallets[_who].lastDividendPeriod;\n        if((balances[_who]==0) || (last==0)){\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\n            return;\n        }\n        if(last==dividendPeriod) {\n            return;\n        }\n        uint share = balances[_who] * 0xffffffff / totalSupply;\n        uint balance = 0;\n        for(;last<dividendPeriod;last++) {\n            balance += share * dividends[last];\n        }\n        balance = (balance / 0xffffffff);\n        walletBalance += balance;\n        wallets[_who].balance += uint208(balance);\n        wallets[_who].lastDividendPeriod = uint16(last);\n        LogDividend(_who,balance,last);\n    }\n\n/* lottery functions */\n\n    function betPrize(Bet _player, uint24 _hash) constant private returns (uint) { // house fee 13.85%\n        uint24 bethash = uint24(_player.betHash);\n        uint24 hit = bethash ^ _hash;\n        uint24 matches =\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\n        if(matches == 6){\n            return(uint(_player.value) * 7000000);\n        }\n        if(matches == 5){\n            return(uint(_player.value) * 20000);\n        }\n        if(matches == 4){\n            return(uint(_player.value) * 500);\n        }\n        if(matches == 3){\n            return(uint(_player.value) * 25);\n        }\n        if(matches == 2){\n            return(uint(_player.value) * 3);\n        }\n        return(0);\n    }\n\n    /**\n     * @dev Check if won in lottery\n     */\n    function betOf(address _who) constant external returns (uint)  {\n        Bet memory player = bets[_who];\n        if( (player.value==0) ||\n            (player.blockNum<=1) ||\n            (block.number<player.blockNum) ||\n            (block.number>=player.blockNum + (10 * hashesSize))){\n            return(0);\n        }\n        if(block.number<player.blockNum+256){\n            \n            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\n        }\n        if(hashFirst>0){\n            uint32 hash = getHash(player.blockNum);\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\n                return(uint(player.value));\n            }\n            else{\n                return(betPrize(player,uint24(hash)));\n            }\n\t}\n        return(0);\n    }\n\n    /**\n     * @dev Check if won in lottery\n     */\n    function won() public {\n        Bet memory player = bets[msg.sender];\n        if(player.blockNum==0){ // create a new player\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n            return;\n        }\n        if((player.value==0) || (player.blockNum==1)){\n            payWallet();\n            return;\n        }\n        require(block.number>player.blockNum); // if there is an active bet, throw()\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\n            LogLate(msg.sender,player.blockNum,block.number);\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n            return;\n        }\n        uint prize = 0;\n        uint32 hash = 0;\n        if(block.number<player.blockNum+256){\n            \n            hash = uint24(block.blockhash(player.blockNum));\n            prize = betPrize(player,uint24(hash));\n        }\n        else {\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\n                hash = getHash(player.blockNum);\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\n                    prize = uint(player.value);\n                }\n                else{\n                    prize = betPrize(player,uint24(hash));\n                }\n\t    }\n            else{\n                LogLate(msg.sender,player.blockNum,block.number);\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n                return();\n            }\n        }\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n        if(prize>0) {\n            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\n            if(prize > maxWin){\n                maxWin = prize;\n                LogRecordWin(msg.sender,prize);\n            }\n            pay(prize);\n        }\n        else{\n            LogLoss(msg.sender,uint(player.betHash),uint(hash));\n        }\n    }\n\n    /**\n     * @dev Send ether to buy tokens during ICO\n     * @dev or send less than 1 ether to contract to play\n     * @dev or send 0 to collect prize\n     */\n    function () payable external {\n        if(msg.value > 0){\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\n                invest(owner);\n            }\n            else{ // if not ICO running payment to contract is treated as play\n                play();\n            }\n            return;\n        }\n        //check for dividends and other assets\n        if(investStart == 0 && balances[msg.sender]>0){\n            commitDividend(msg.sender);}\n        won(); // will run payWallet() if nothing else available\n    }\n\n    /**\n     * @dev Play in lottery\n     */\n    function play() payable public returns (uint) {\n        return playSystem(uint(sha3(msg.sender,block.number)), address(0));\n    }\n\n    /**\n     * @dev Play in lottery with random numbers\n     * @param _partner Affiliate partner\n     */\n    function playRandom(address _partner) payable public returns (uint) {\n        return playSystem(uint(sha3(msg.sender,block.number)), _partner);\n    }\n\n    /**\n     * @dev Play in lottery with own numbers\n     * @param _partner Affiliate partner\n     */\n    function playSystem(uint _hash, address _partner) payable public returns (uint) {\n        won(); // check if player did not win\n        uint24 bethash = uint24(_hash);\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\n        if(msg.value > 0){\n            if(investStart==0) { // dividends only after investment finished\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\n            }\n            if(_partner != address(0)) {\n                uint fee = msg.value / 100;\n                walletBalance += fee;\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\n            }\n            if(hashNext < block.number + 3) {\n                hashNext = block.number + 3;\n                hashBetSum = msg.value;\n            }\n            else{\n                if(hashBetSum > hashBetMax) {\n                    hashNext++;\n                    hashBetSum = msg.value;\n                }\n                else{\n                    hashBetSum += msg.value;\n                }\n            }\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\n            LogBet(msg.sender,uint(bethash),hashNext,msg.value);\n        }\n        putHash(); // players help collecing data\n        return(hashNext);\n    }\n\n/* database functions */\n\n    /**\n     * @dev Create hash data swap space\n     * @param _sadd Number of hashes to add (<=256)\n     */\n    function addHashes(uint _sadd) public returns (uint) {\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\n        uint n = hashes.length;\n        if(n + _sadd > hashesSize){\n            hashes.length = hashesSize;\n        }\n        else{\n            hashes.length += _sadd;\n        }\n        for(;n<hashes.length;n++){ // make sure to burn gas\n            hashes[n] = 1;\n        }\n        if(hashes.length>=hashesSize) { // assume block.number > 10\n            hashFirst = block.number - ( block.number % 10);\n            hashLast = hashFirst;\n        }\n        return(hashes.length);\n    }\n\n    /**\n     * @dev Create hash data swap space, add 128 hashes\n     */\n    function addHashes128() external returns (uint) {\n        return(addHashes(128));\n    }\n\n    function calcHashes(uint32 _lastb, uint32 _delta) constant private returns (uint) {\n        \n        return( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\n        \n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\n            \n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\n            \n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\n            \n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\n            \n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\n            \n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\n            \n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\n            \n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\n            \n            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\n            | ( ( uint(_delta) / hashesSize) << 240));\n    }\n\n    function getHash(uint _block) constant private returns (uint32) {\n        uint delta = (_block - hashFirst) / 10;\n        uint hash = hashes[delta % hashesSize];\n        if(delta / hashesSize != hash >> 240) {\n            return(0x1000000); // load failed, incorrect data in hashes\n        }\n        uint slotp = (_block - hashFirst) % 10;\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\n    }\n\n    /**\n     * @dev Fill hash data\n     */\n    function putHash() public returns (bool) {\n        uint lastb = hashLast;\n        if(lastb == 0 || block.number <= lastb + 10) {\n            return(false);\n        }\n        uint blockn256;\n        if(block.number<256) { // useless test for testnet :-(\n            blockn256 = 0;\n        }\n        else{\n            blockn256 = block.number - 256;\n        }\n        if(lastb < blockn256) {\n            uint num = blockn256;\n            num += num % 10;\n            lastb = num;\n        }\n        uint delta = (lastb - hashFirst) / 10;\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\n        hashLast = lastb + 10;\n        return(true);\n    }\n\n    /**\n     * @dev Fill hash data many times\n     * @param _num Number of iterations\n     */\n    function putHashes(uint _num) external {\n        uint n=0;\n        for(;n<_num;n++){\n            if(!putHash()){\n                return;\n            }\n        }\n    }\n\n}\n\n```\n\n---\n\n## YOUR ANALYSIS\n\nFollowing the pattern shown in the examples:\n\n### 1. Contract Overview\n- What is this contract's purpose?\n- What assets does it manage?\n- Who are the intended users?\n\n### 2. Function-by-Function Security Analysis\nFor each function, analyze:\n- Access control: Who can call it?\n- State changes: What is modified?\n- External interactions: Any calls to other contracts?\n- Trust assumptions: What must be true for safety?\n\n### 3. Vulnerability Pattern Matching\nCompare the target contract to each example above:\n- Does it have patterns similar to Example 1 (arithmetic)?\n- Does it have patterns similar to Example 2 (unchecked_low_level_calls)?\n- Does it have patterns similar to Example 3 (reentrancy)?\n- Does it have patterns similar to Example 4 (denial_of_service)?\n- Does it have patterns similar to Example 5 (denial_of_service)?\n\n### 4. Evidence Documentation\nFor any vulnerability found:\n- Identify exact line numbers\n- Identify the vulnerable function\n- Describe a concrete attack scenario\n- Explain how the vulnerability could be exploited\n\n---\n\n## OUTPUT FORMAT\n\nProvide your findings as a JSON array. Include ONLY vulnerabilities you have high confidence in, with concrete evidence:\n\n```json\n[\n  {\n    \"category\": \"DASP category (reentrancy, access_control, arithmetic, unchecked_low_level_calls, denial_of_service, bad_randomness, front_running, time_manipulation, short_addresses, other)\",\n    \"title\": \"Descriptive vulnerability title\",\n    \"evidence\": {\n      \"file\": \"contract.sol\",\n      \"lines\": [line_numbers_where_vulnerability_exists],\n      \"function\": \"vulnerable_function_name\"\n    },\n    \"explanation\": \"Clear explanation of the vulnerability and how an attacker could exploit it\"\n  }\n]\n```\n\nReturn `[]` if no vulnerabilities are found after thorough analysis.\n\n---\n\nAnalyze the target contract using the methodology demonstrated in the examples above. Be thorough but precise - only report vulnerabilities you can clearly demonstrate with evidence.",
    "api_calls": 42,
    "latency_s": 659.1529498100281
  }
}