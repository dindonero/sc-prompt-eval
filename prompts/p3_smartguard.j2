## SMARTGUARD-STYLE AUDIT: RAG + CoT + Self-Check

You are a security auditor specializing in Solidity smart contracts. This audit uses the SmartGuard methodology combining:
1. **Retrieval-Augmented Generation (RAG)**: Learning from similar vulnerable contracts
2. **Chain-of-Thought (CoT)**: Structured reasoning through each vulnerability check
3. **Self-Check**: Validation of findings before final output

---

## PHASE 1: RETRIEVAL-AUGMENTED CONTEXT

The following vulnerability patterns have been retrieved based on structural similarity to your target contract. Use these as reference for your analysis:

{% if retrieved_patterns %}
{% for pattern in retrieved_patterns %}
### Retrieved Pattern {{ loop.index }}: {{ pattern.category }}
**Title**: {{ pattern.title }}
**Description**: {{ pattern.description }}

**Code Example**:
```solidity
{{ pattern.vulnerable_code }}
```
{% if pattern.get('chain_of_thought') %}

**Analysis (Chain-of-Thought)**:
{{ pattern.chain_of_thought }}
{% endif %}

**Detection Hint**: {{ pattern.detection_hint }}

---
{% endfor %}
{% else %}
### Common Vulnerability Patterns (DASP Top 10)
Use your knowledge of common Solidity vulnerabilities including:
- reentrancy: External calls before state updates
- arithmetic: Unchecked arithmetic in pre-0.8 Solidity (overflow/underflow)
- access_control: Missing authorization checks
- unchecked_low_level_calls: Ignoring call return values
- time_manipulation: Using block.timestamp for critical logic
- bad_randomness: Predictable random number generation
- denial_of_service: Gas limits and failed call dependencies
- front_running: Transaction order dependence

---
{% endif %}

## PHASE 2: TARGET CONTRACT

```solidity
{{ contract_source }}
```

---

## PHASE 3: CHAIN-OF-THOUGHT AUDIT METHODOLOGY

Perform a systematic audit following this structured reasoning process:

### Step 1: Contract Overview
- What is the contract's purpose?
- What assets does it manage (ETH, tokens, data)?
- What are the main entry points (external/public functions)?

### Step 2: Function-by-Function Analysis
For EACH function, reason through:
- Who can call it? (access control)
- What state does it modify?
- Does it make external calls? If so, when?
- Are there any trust assumptions?

### Step 3: Vulnerability Pattern Matching
For each retrieved pattern above, explicitly check:
- Does the target contract have similar code structures?
- Are the same vulnerability conditions present?
- What context differences might affect exploitability?

### Step 4: Attack Scenario Construction
For each potential vulnerability:
- Describe a concrete attack scenario step-by-step
- Identify preconditions for the attack
- Estimate impact and likelihood

---

## PHASE 4: INITIAL FINDINGS

Based on your chain-of-thought analysis, document all potential vulnerabilities:

[Document each finding with evidence before proceeding to self-check]

---

## PHASE 5: SELF-CHECK VALIDATION

Before finalizing, critically review EACH finding:

### Self-Check Criteria:
1. **Evidence Verification**: Are the line numbers and function names correct?
2. **Reasoning Consistency**: Does the chain of thought logically lead to this conclusion?
3. **Exploitability Reality Check**: Is this actually exploitable in practice?
4. **Context Consideration**: Are there mitigating factors not initially considered?
5. **False Positive Filter**: Could this be a non-issue mistaken for a vulnerability?

### For each finding, ask:
- "If I were defending this code, what would I argue?"
- "Is there a legitimate reason for this pattern?"
- "Does the evidence actually support my claim?"

**REMOVE or DOWNGRADE** findings that fail self-check validation.

---

## OUTPUT FORMAT

Provide your FINAL validated findings as a JSON array:

```json
[
  {
    "category": "DASP category (reentrancy, access_control, arithmetic, etc.)",
    "title": "Vulnerability title",
    "evidence": {
      "file": "contract.sol",
      "lines": [line_numbers],
      "function": "function_name"
    },
    "explanation": "Clear explanation of the vulnerability and how it could be exploited"
  }
]
```

Return `[]` if no vulnerabilities survive the complete RAG + CoT + Self-Check process.

---

Now perform the complete SmartGuard-style audit. Show your reasoning, then validate each finding before producing the final JSON output.
